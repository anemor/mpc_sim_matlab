p = [0.5 0 5]';
v = zeros(3,1);
q =[1 0 0 0]';
w = [0 0 0]';

x = [p;v;q;w]
    
u = [deg2rad(2),deg2rad(5),0.5,0]';

%xdot = state_dynamics_f(x, u, zeros(3,1), zeros(3,1))

%[thrust_prop_vec, torque_prop_vec] = actuator_dynamics(u);

ct = 10;
st = 2;
cp = 50;
sp = 3;
Ry = [  ct 0 st;
        0 1 0;
        -st 0 ct];
Rz = [  cp -sp 0;
        sp cp 0;
        0 0 1];

Ryz = Ry*Rz


v1 = [1,2,3]' 
q90 = euler_to_quat([0,deg2rad(-90),0])
q180 = euler_to_quat([0,deg2rad(-180),0])
q270 = euler_to_quat([0,deg2rad(-270),0])
q360 = euler_to_quat([0,deg2rad(-360),0])

disp('v1 rotated once')
rot90 = v_rotate(q90, v1)
rot180 = v_rotate(q180, v1)
rot270 = v_rotate(q270, v1)
rot360 = v_rotate(q360, v1)

disp('v1 rotated using 90 multiple times')
rot90 = v_rotate(q90, v1)
rot180 = v_rotate(q90, rot90)
rot270 = v_rotate(q90, rot180)
rot360 = v_rotate(q90, rot270)

disp('v1 rotated by combining rotations')
rot90 = v_rotate(q90, v1)
rot180 = v_rotate(quat_prod(q90, q90), v1)
rot270 = v_rotate(quat_prod(q90, quat_prod(q90, q90)), v1)
rot360 = v_rotate(quat_prod(q90, quat_prod(q90, quat_prod(q90, q90))), v1)


q_bn_const = euler_to_quat([0 deg2rad(90) 0]) 

rot90 = v_rotate(q_bn_const, [19 0 -3]') 
rot90_back = v_rotate(quat_conj(q_bn_const), rot90) 

euler = quat_to_euler([0, sqrt(2)/2, sqrt(2)/2, 0])
euler_deg = [rad2deg(euler(1)), rad2deg(euler(2)), rad2deg(euler(3))]


g_n = [0 0 9.81]'
g_b = [-9.81 0 0]'
g_n_rot = v_rotate(q_bn_const, g_b)


%% Quaternion error
q_d = euler2q(0,0,0); %[1 0 0 0]'
q = euler2q(0, deg2rad(90), deg2rad(50))

q_err = quat_error(q, q_d)
[roll,pitch,yaw] = q2euler(q_err);
roll = rad2deg(roll)
pitchh = rad2deg(pitch)
yaww = rad2deg(yaw)

disp(['euler error', rad2deg(roll), rad2deg(pitch), rad2deg(yaw)]);

%%
function [thrust_prop_vec_b, torque_prop_vec_b] = actuator_dynamics(u)
    % in: u = [linac_pitch_p, linac_yaw_p, prop_speed_avg, prop_speed_diff]
    % out: thrust_prop_vec_b, torque_prop_vec_b

    % Constants / parameters 
    thrust_scale = 1;
    torque_scale = 1;

    linac_pitch = u(1);
    linac_yaw = u(2);
    prop_speed_avg = u(3);
    prop_speed_diff = u(4);

    % Thrust force and torque generated by propellers
    thrust_prop_abs = get_propeller_thrust(prop_speed_avg) * thrust_scale;
    torque_prop_abs = get_propeller_torque(prop_speed_diff) * torque_scale;

    R_bp = Rzyx(0,u(1),u(2)) % seems correct to transform to body frame
    thrust_prop_vec_p = [thrust_prop_abs 0 0]';
    thrust_prop_vec_b = R_bp * thrust_prop_vec_p; %- distance_rocket_gimbal;

    torque_prop_vec_p = [torque_prop_abs 0 0]'; 
    torque_prop_vec_b = R_bp * torque_prop_vec_p; % - distance_rocket_gimbal;
end

function R = Rzyx(roll,pitch,yaw)
    % R = Rzyx(phi,theta,psi) computes the Euler angle
    % rotation matrix R in SO(3) using the zyx convention
    %
    % Author:   Thor I. Fossen
    % Date:     14th June 2001
    % Revisions: 
    
    cphi = cos(roll);
    sphi = sin(roll);
    cth  = cos(pitch);
    sth  = sin(pitch);
    cpsi = cos(yaw);
    spsi = sin(yaw);
     
    R = [...
       cspi*cth  -spsi*cphi+cpsi*sth*sphi  spsi*sphi+cpsi*cphi*sth
       spsi*cth  cpsi*cphi+sphi*sth*spsi   -cpsi*sphi+sth*spsi*cphi
       -sth      cth*sphi                  cth*cphi ];
end



function [q] = quat_prod(q1, q2)
    % MSS
    eta1  = q1(1);
    eps1  = q1(2:4);
    eta2  = q2(1);
    eps2  = q2(2:4);

    q = [eta1*eta2 - eps1'*eps2
        eta2*eps1 + eta1*eps2 + cross(eps1,eps2)];
    % if q(1) < 0 % handling quaternion ambiguity
    %     q = -q;
    % end
    % if q(1) ~= 0
    %     q = q / norm(q);            % normalize if q is not a vector [0 v1 v2 v3], handle round-off errors 
    % end
end


function [q] = euler_to_quat(euler)
    roll = euler(1);
    pitch = euler(2);
    yaw = euler(3);

    cy = cos(roll * 0.5);
    sy = sin(roll * 0.5);
    cp = cos(pitch * 0.5);
    sp = sin(pitch * 0.5);
    cr = cos(yaw * 0.5);
    sr = sin(yaw * 0.5);
    
    q = [cy * cp * cr + sy * sp * sr
         cy * cp * sr - sy * sp * cr
         sy * cp * sr + cy * sp * cr
         sy * cp * cr - cy * sp * sr];
    
    q = q/(q'*q);
    
end

function q_conj = quat_conj(q)
    q_conj = [q(1); -q(2:4)];
end


function v_rot = v_rotate(q, v)
    % v_rot = qvq_conj(q, v) rotates vector v by quaternion q
    % passive rotation = the coordinate system is rotated with respect to the vector.
    % since quaternion multiplication is associative, the order (qp)q−1 or q(pq−1) doesn't matter
    q = q / sqrt(q'*q);

    if v == [0; 0; 0]
        v_rot = v;
        return
    end
    v_quat = [0; v];
    qv = quat_prod(q, v_quat);
    v_rot_quat = quat_prod(qv, quat_conj(q));
    v_rot = v_rot_quat(2:4);
end

function [euler] = quat_to_euler(q)
    q = q / norm(q);            % normalize q, handle round-off errors 
    R = Rquat(q);
    
    roll = atan2(R(3,2),R(3,3));
    
    if (abs( R(3,1 )) > 1)      % handle NaN due to round-off errors
        R(3,1) = sign(R(3,1));
    end
    
    pitch = -asin(R(3,1));
    yaw = atan2(R(2,1),R(1,1));

    euler = [roll, pitch, yaw];
end